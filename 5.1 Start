using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;


namespace CodingCoursesButThisTimeForFree
{
    internal class program
    {
        static void Main(string[] args)
        {
            //bool isTimed = true; //timed 
            //long currentTime = 0;
            //long duration = 100;
            //Stopwatch timer = new Stopwatch();
            int middleMenuStartX = 55;
            int middleMenuStartY = 14;
            int selectorCharXPos = middleMenuStartX - 2;
            int selectorCharYPos = middleMenuStartY;
            int selectedOption = 0;
            bool isOptionSelected = false;
            ConsoleKeyInfo pressedKey = new ConsoleKeyInfo();
            Dictionary<string, string> residents = new Dictionary<string, string>();
            string userInput = null;

            List<string> mainOptions = new List<string>();
            mainOptions.AddRange(new string[] { "New Game", "Settings", "Exit" });
            List<string> onlyOption = new List<string>();
            onlyOption.AddRange(new string[] { "Yes" });
            List<string> languageSelect = new List<string>();
            languageSelect.AddRange(new string[] { "English", "Russian" });

            //testing
            //MenuInput(mainOptions, out isOptionSelected, ref selectedOption, selectorCharXPos, ref selectorCharYPos, middleMenuStartX, middleMenuStartY);
            //Console.ReadKey();
            //

            Console.CursorVisible = false;

            while (!isOptionSelected)
            {
                SelectOption(languageSelect, out isOptionSelected, ref selectedOption, selectorCharXPos, ref selectorCharYPos, middleMenuStartX, middleMenuStartY);
                Console.Clear();
            }

            Console.CursorVisible = true;

            switch (selectedOption)
            {
                case 0:
                    Console.WriteLine("Enter Resident:");
                    userInput = Console.ReadLine();
                    Console.WriteLine(userInput);
                    break;
                case 1:
                    Console.WriteLine("option 2 selected");
                    break;
            }
        }

        static void DrawHoverChar(int menuStartX, int menuStartY, bool isVisible = true, ConsoleColor color = ConsoleColor.Blue)
        {
            char hoverChar = 'â™¦';
            Console.SetCursorPosition(menuStartX - 2, menuStartY);

            if (isVisible == true)
            {
                ColorizeChar(hoverChar, color);
            }
        } //menu CHAR

        static void DrawMenu(List<string> options, ref int selectorCharYPos, int selectedOption, int menuStartX = 55, int menuStartY = 14)
        {
            for (int i = 0; i < options.Count; i++)
            {
                if (selectedOption == i)
                {
                    WriteOffset($" {options[i]} ", menuStartX, menuStartY + i, false, 0, true);
                    DrawHoverChar(menuStartX, menuStartY + i, true);
                }
                else
                {
                    WriteOffset($" {options[i]} ", menuStartX, menuStartY + i, false, 0, false);
                }
            }
        }  //menu DRAW

        static void SelectOption(List<string> options, out bool isOptionSelected, ref int selectedOption, int selectorCharXPos, ref int selectorCharYPos, int menuStartX = 55, int menuStartY = 14)
        {
            ConsoleKeyInfo pressedButton = new ConsoleKeyInfo();
            pressedButton = new ConsoleKeyInfo();
            isOptionSelected = false;

            DrawMenu(options, ref selectorCharYPos, selectedOption, menuStartX, menuStartY);
            pressedButton = Console.ReadKey();

            switch (pressedButton.Key)
            {
                case ConsoleKey.UpArrow:
                case ConsoleKey.W:
                    if (selectorCharYPos != menuStartY)
                    {
                        selectorCharYPos--;
                        selectedOption--;
                    }
                    break;

                case ConsoleKey.DownArrow:
                case ConsoleKey.S:
                    if (selectorCharYPos != menuStartY - 1 + options.Count)
                    {
                        selectorCharYPos++;
                        selectedOption++;
                    }
                    break;

                case ConsoleKey.Enter:
                case ConsoleKey.Spacebar:
                    isOptionSelected = true;
                    //if (selectorCharYPos == menuStartY)
                    //    menuOption = 1;
                    //else if (selectorCharYPos == menuStartY++)
                    //    menuOption = 2;
                    //else if (selectorCharYPos == menuStartY++)
                    //    menuOption = 3;
                    break;
            }
        } //menu INPUT

        static void WriteOffset(string text, int xPosition = 47, int yPosition = 14, bool isTimed = false, long duration = 1600, bool isSelected = false, ConsoleColor selectionColor = ConsoleColor.Blue)
        {
            Stopwatch timer = new Stopwatch();
            long currentTime = 0;

            ClearInput(xPosition, yPosition, text.Length);
            Console.SetCursorPosition(xPosition, yPosition);
            ConsoleHelper.SetCurrentFont("Consolas", 28);

            if (isSelected)
            {
                Console.BackgroundColor = selectionColor;
                Console.WriteLine(text);
                Console.BackgroundColor = ConsoleColor.Black;
            }
            else
            {
                Console.WriteLine(text);
            }

            Console.SetCursorPosition(0, 0);

            if (isTimed)
            {
                while (currentTime < duration)
                {
                    timer.Start();
                    currentTime = timer.ElapsedMilliseconds;
                }

                timer.Stop();
                ClearInput(xPosition, yPosition, text.Length);
            }
        } //write TEXT

        static void WriteInLog(string text, int xPos = 1, int yPos = 13)
        {
            ClearInput(xPos, yPos);
            Console.SetCursorPosition(xPos, yPos);
            Console.Write(text);
        } //write LOG

        static void ClearInput(int xPos = 0, int yPos = 0, int length = 0)
        {
            Console.SetCursorPosition(xPos, yPos);

            for (int i = 0; i < length; i++)
                Console.Write(" ");
        } //clear

        static void ColorizeChar(char character, ConsoleColor color)
        {
            Console.ForegroundColor = color;
            Console.Write(character);
            Console.ForegroundColor = ConsoleColor.White;
        } //colored text

        static void ColorozeBackground(char character, ConsoleColor color)
        {
            Console.BackgroundColor = color;
            Console.ForegroundColor = color;
            Console.Write(character);
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.White;
        } //colored BG

        public static class ConsoleHelper
        {
            private const int FixedWidthTrueType = 54;
            private const int StandardOutputHandle = -11;

            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern IntPtr GetStdHandle(int nStdHandle);

            [return: MarshalAs(UnmanagedType.Bool)]
            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern bool SetCurrentConsoleFontEx(IntPtr hConsoleOutput, bool MaximumWindow, ref FontInfo ConsoleCurrentFontEx);

            [return: MarshalAs(UnmanagedType.Bool)]
            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern bool GetCurrentConsoleFontEx(IntPtr hConsoleOutput, bool MaximumWindow, ref FontInfo ConsoleCurrentFontEx);


            private static readonly IntPtr ConsoleOutputHandle = GetStdHandle(StandardOutputHandle);

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            public struct FontInfo
            {
                internal int cbSize;
                internal int FontIndex;
                internal short FontWidth;
                public short FontSize;
                public int FontFamily;
                public int FontWeight;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                //[MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.wc, SizeConst = 32)]
                public string FontName;
            }

            public static FontInfo[] SetCurrentFont(string font, short fontSize = 0)
            {
                //Console.WriteLine("Set Current Font: " + font);

                FontInfo before = new FontInfo
                {
                    cbSize = Marshal.SizeOf<FontInfo>()
                };

                if (GetCurrentConsoleFontEx(ConsoleOutputHandle, false, ref before))
                {

                    FontInfo set = new FontInfo
                    {
                        cbSize = Marshal.SizeOf<FontInfo>(),
                        FontIndex = 0,
                        FontFamily = FixedWidthTrueType,
                        FontName = font,
                        FontWeight = 400,
                        FontSize = fontSize > 0 ? fontSize : before.FontSize
                    };

                    // Get some settings from current font.
                    if (!SetCurrentConsoleFontEx(ConsoleOutputHandle, false, ref set))
                    {
                        var ex = Marshal.GetLastWin32Error();
                        Console.WriteLine("Set error " + ex);
                        throw new System.ComponentModel.Win32Exception(ex);
                    }

                    FontInfo after = new FontInfo
                    {
                        cbSize = Marshal.SizeOf<FontInfo>()
                    };
                    GetCurrentConsoleFontEx(ConsoleOutputHandle, false, ref after);

                    return new[] { before, set, after };
                }
                else
                {
                    var er = Marshal.GetLastWin32Error();
                    Console.WriteLine("Get error " + er);
                    throw new System.ComponentModel.Win32Exception(er);
                }
            }
        } //font and font size
    }
}

